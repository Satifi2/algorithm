//一开始题目看错了，是第i战舰(所在列的所有战舰)接在战舰j（所在列）的尾部，不是第i列战舰接在第j列尾部【那样更难搞】
/*
4
M 2 3
C 1 2
M 2 4
C 4 2

有4战舰
1 2 3 4
第一次2 移动到3尾部
1 . 3 4
    2
    
查询1 2，不在同一列，返回-1

第二次，移动战舰2所在列到战舰4所在列尾部

1 . . 4 
      3
      2
查询4，2，之间间隔了1战舰


暴力方法就是模拟战舰,比如ships[i]表示第i列所有战舰，但是战舰有3e4，每次找到指定战舰就是3e4
移动最多也是3e4,查询也是，总的就是一定过不了
*/

//暴力方法还是得练，因为是基本功，而且骗分比较重要

//现在需要思考并查集写法
//首先思考假设只需要判定战舰是否在同一列如何解决
//裸的并查集可以解决，i表示战舰，同时是节点，M操作就是把战舰i所在集合（树）合并到集合j当中【同一列是一颗树】
//*********************可视化之后就是，每列一颗树，根节点是排头，每一个节点指向的父节点总是在自己前面
//查询就是判断ij是否在同一个集合 ,确实是裸的并查集，但是要考虑靠后多少个，所以还要考虑？
//首先集合大小很容易维护
//如果要遍历所有战舰找出距离还是很麻烦的，所以可以维护所有战舰距离排头的距离（排头到自己的距离=0）
//但是如何维护，自然的想法是排头作为树根节点

//******************dis i表示节点i到父节点father[i]对应的战舰的真实距离【注意不是树上距离，不然距离肯定是1，是在战舰队列里面的真实距离】
//刚开始的时候dis i都是0，到father[i]自己的真实距离为0
//假设战舰1 移动到2后面，dis[1]=1,dis[2]=0，一并移动到战舰3，dis[1]=1,dis[2]=1,dis[3]=0【假设没有find操作】
//一并移动到战舰4，dis[1]=1,dis[2]=1,dis[3]=1,dis[4]=0
//这里可以看出两点，1 合并到战舰j所在列，战舰j所在树的根要作为新的根，不能是战舰i，否则非对称性就没有了
// 2  移动的时候除了战舰i的树根对应的dis变了其他都没有变，这是因为
//本来战舰ij所在队列有若干节点，每一个节点的father一定在同一列当中
//现在移动了战舰i到战舰j所在列，原来战舰j所在列的战舰和其father的相对位置一定没有变，所以dis不变
//战舰i所在列的战舰（除了战舰i的根，也就是排头）和其father相对位置也没有变，所以dis不变
//变了的就是战舰i排头的dis，也就是根元素的dis，它应该变成战舰j所在集合大小，因为比如说战舰j所在集合大小是3【有三战舰】
//第四战舰到排头的距离就是3【到自己是0】
//综上所述，维护size father基础上维护dis,合并后旧根dis=size 合并前的新根

//然后要考虑路径压缩，假设战舰1 移动到2后面，dis[1]=1,dis[2]=0，一并移动到战舰3，dis[1]=1,dis[2]=1,dis[3]=0
//现在假设进行了一个find操作，father[1]=2,father[2]=3,find(1)调用find2,find(2)调用find(3)
//然后路径压缩，导致father[2]=3,没有变化，father[1]=3,根据定义dis[1]表示战舰1到3的真实距离，也就是2，不是3，变了
//所以还需要更新，也就是操作一致性问题，更改父元素同时更改了到父元素的真实距离，这一个距离应该=1到父元素的真实距离+父元素到根的真实距离
//也就是d[x]+=d[p[x]],这里d[p[x]]本来表示父元素到父元素的真实距离，但是路径压缩后父元素的父元素就是根，所以这里就是
//父元素到根的真实距离

#include<iostream>
using namespace std;
const int N = 3e4+3;
int father[N],siz[N],disf[N];//disf表示战舰i到父元素的真实距离
int find(int i){
    if(father[i]==i)return i;//如果是根直接返回，因为没有发生操作，无需维持状态一致性
    int root=find(father[i]);
    disf[i]+=disf[father[i]],father[i]=root;//操作一致性，更改父节点必然导致到父节点的真实距离变化
    //到父节点真实距离=到根真实距离=到原来父节点真实距离d[i]+原来父节点到根真实距离d[father[i]]【父节点的父节点就是根】
    //注意，顺序不能错，不然原来的父节点不见了
    return root;
}

void print(){
    cout<<"father:   ";
    for(int i=1;i<=4;i++)cout<<father[i]<<" ";
    cout<<endl<<"size   ";
    for(int i=1;i<=4;i++)cout<<siz[i]<<" ";
    cout<<endl<<"disf    ";
    for(int i=1;i<=4;i++)cout<<disf[i]<<" ";
    cout<<endl<<endl;
}

int main(){
    for(int i=0;i<N;i++)father[i]=i,siz[i]=1;//居然没有初始化siz，【d不需要初始化，因为节点都是根，到父节点距离是0】
    int t;
    cin>>t;
    // print();
    while(t--){
        char op;
        cin>>op;
        int i,j;//直接看作两个节点编号
        cin>>i>>j;
        int origini=i,originj=j;
        i=find(i),j=find(j);
        if(op=='M'){
            if(i!=j)father[i]=j,disf[i]=siz[j],siz[j]+=siz[i];//操作一致性，同一个操作”移动战舰i到j“导致不同状态变化
            //注意排头总是根元素【只需要总是让j所在集合根元素作为新的根就能保证，数学归纳法可以证明】
            //注意，siz[j]必须要最后变化，否则disf[i]错了
        }
        else {
            if(i!=j)cout<<-1<<endl;//根元素不同，不在同一颗树，所以不在同一列
            else cout<<max(0,abs(disf[origini]-disf[originj])-1)<<endl;//在同一颗树，到根元素也就是排头，d[i]本来表示i到父节点的距离，但是
            //find处理过，导致d[i]父节点是根元素，导致d[i]表示到根元素也就是排头的距离
            //注意，这里有一个大坑，是要找节点i和j到根节点的真实距离只差，但是ij已经变成根节点了，距离没有差别，所以
            //保留ij是一个好习惯
            
            //居然还有一个坑，位置10 和 11之间相差0，位置10 和 10 之间也是0，而不是-1
        }
        // print();
    }
    
    return 0;
}
//理解得很清楚了
