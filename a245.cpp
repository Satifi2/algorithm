/*
5 3
1 2 -3 4 5
1 2 3
2 2 -1
1 3 2


意思是：
arr[1~5],有三个操作
arr=[0,1,2,-3,4,5]
然后第一个操作类型1，表示查询，查询区间2 3之间的最大子段和，也就是单独一个数字2
然后操作2，表示修改，修改第2个数为-1，也就是[0,1,-1,-3,4,5]
之后查询，区间[2,3]（要自己处理顺序），之间的最大字段和，那就是单独一个数字-1

线段树维护最值，总和都没有问题，因为分组定理
但是如何维护最大子段和？
问题：能否从左段，右段得知最大子段和，答案是不够，因为有可能左段很大，右段很大，但是都没有两段中间大
例如[7,-999,5],[5,-999,7]左边是7，右边是7，但是最大是10
根据分组最值定理，我们把区间分成三种，分组最值，还漏掉了一种，所以才会导致错误
跨中间的最大子段和=独立贪心定理，左区间贴着右边的最大子段和+右区间贴着左边的最大子段和
这里有两个问题：1如果左区间贴着右边的最大字段和是负数，会导致错误吗，其实不会
因为这样右区间最大子段和>=右区间贴着左边的最大子段和>右区间贴着左边的最大子段和+左区间贴着右边的最大子段和
保证了答案一定不是跨区间的，也就是tmax=max(左区间rmax+右区间lmax,左区间tmax,右区间.tmax)一定是对的
[本来不对是因为跨区间可能更大，现在已经考虑这一种情况了，即使跨区间更小也不会被记录]

但是lmax,rmax也需要从子区间求出
对于lmax是所有贴着左边的区间的子段和 的最大值，分组定理表示
或者说lmax=max(f(l1),f(l2),f(l3)...)其中l1是第一个左区间，f表示区间和，分组成两种，没有跨区间的
lmax=左区间的lmax，跨区间的lmax=左区间sum+右区间lmax
同理如果右区间lmax是负数，最后一定会采取没有区间的策略，因此lmax=max(左区间lmax,右区间lmax+左区间sum)
rmax=max(右区间rmax，左区间rmax+右区间sum)
最后还要维护一个sum，sum=sum(左区间)+sum(右区间)

这里有一个有意思的事情，我们并没有用到常见的dp思想，也就是dp[i]=arr[i]+max(0,dp[i-1])
但是是可以解决的，只有两个数[2, -3]
左区间的tmax=2【***********至少选一个数，不可以不选】,rmax=2,lmax=2,sum=2，也就是都是自己
右边也是一样，sum=2+-3=-1
tmax=max(2,-3,2+-3)也就2，其中2+-3表示跨区间【两边至少都选一个】
rmax=max(-3,-3+2)=1【rmax也是，至少有最右边的那一个数，不可以没有】
lmax=max(2,2+-3)也就是2
都是没有问题的
*/
#include<iostream>
using namespace std;
const int N = 5e5+3;
int arr[N];
struct Node{
    int l,r,tmax,lmax,rmax,sum;//最大值可以只用int，区间和最大是1e3*5e5=1e8不会爆int
}

int main(){
    ios::sync_with_stdio(0);
    cin.tie(0);//数据有点大
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++)cin>>arr[i];
    for(int i=1;i<=m;i++){
        int op,x,y;
        cin>>op>>x>>y;
        if()
    }
    
    return 0;
}

