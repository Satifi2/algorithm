/*
初次看到炸弹，感觉好像是搜索，但是要考虑xi和yi都是小于5000的，也就是说地图很小
2 1
0 0 1
1 1 1
意思是有两个坐标，一个是(0,0)价值是1，还有一个是(1,1)价值是1
现在炸弹的范围是边长为1的正方形，但是这里的正方形描述不是很准确，准确来说是可以炸掉一个点
如果R=2,就可以炸掉2*2个点

现在问炸掉的最大价值是什么？

暴力方法，所有可以的炸法都枚举一遍，然后取最大值
时间复杂度是5000*5000选择正方形左上角的落点，然后求炸掉的东西，其实就是总和，二维前缀和就是O(1)，所以可以过

问题：如果R==5000，可以炸掉5000*5000的点
但是不难发现原来的范围是0-5000,其实还是不够的
如果R>=5001，就全部炸掉即可，和R=5001等价

还有一个问题，怎么求二维前缀和，由于二维前缀和最好的求法是从1开始数，所以这里的坐标要全部+1，也就是从1到5001【猜对了】

怎么枚举炸掉哪里，答案是，枚举左上角的点(x,y)从(1,1)开始枚举，枚举到边长为R的正方形正好卡在大正方形的右下角
想象一下，比如R=3, 此时的(x,y)=(4999,4999),也就是(5001-R+1)
*/
#include<iostream>
using namespace std;
// const int N = 5e3+5;
const int M = 5001,N=M+5;
int psum[N][N];//N比M大，是因为arr[5001]会越界
//arr[N][N],
//本题的空间限制是168MB,N*N=25e6=2e7个int，也就是8e7个B，也就是80e6=80M个Byte，如果开两个恰好越界
//所以本题必须要只用前缀和，没有原数组

int main(){
    int res=0;//如果res=第一个元素就不需要考虑别的了，res的值其实是要保证和第一个元素取最值得第一个元素，相当于
    //所有元素取最值，而没有常数参与
    //这里是不会爆int的，因为所有wi相加最多是1000（个数）*10000（wi）
    int n,R;
    cin>>n>>R;
    R=min(R,M);//如果R=6000,变成5001,for(int i=1;i<=5001-5001+1;i++)相当于只有一个正方形
    for(int i=1;i<=n;i++){
        int x,y,w;
        cin>>x>>y>>w;
        x++,y++;
        //arr[x][y]=w，直接存在前缀和数组里面
        psum[x][y]+=w;//这里其实没法同步求psum，因为不是给arr[i][j],也就是只给了很少的点，所以需要遍历所有点
        //这里也太坑了吧，价值居然可以累计
    }
    for(int i=1;i<=M;i++){//注意遍历范围是1-5100，求出psum[1-5001][1-5001]
        for(int j=1;j<=M;j++){
            psum[i][j]=psum[i-1][j]+psum[i][j-1]-psum[i-1][j-1]+psum[i][j];//arr[i][j];
            //直接在原数组上面的求前缀和是没有问题的，因为i顺j拟的时候，ij的上边，左边，左上角都表示前缀和，ij表示
            //arrij,所以是等价的。实际上一维前缀和也是可以的
        }
    }
    for(int i=1;i<=M-R+1;i++){//正方形在左上角遍历
        for(int j=1;j<=M-R+1;j++){
            res=max(res,psum[i+R-1][j+R-1]-psum[i-1][j+R-1]-psum[i+R-1][j-1]+psum[i-1][j-1]);
            //我们是想要求左上角到右下角的前缀和【含边界】
            //[i+R-1][j+R-1]是右下角坐标，R=1的时候右下角和左上角重合
            //[i-1][j+R-1]是行上移-1,psum[i+R-1][j-1]是列左移-1,[i-1][j-1]是都有，也就是正方形左上角的左上角
            //看来自然语言总结这一个公式有用
        }
    }
    cout<<res;
    
    return 0;
}
//时间复杂度M*M

//总结：很简单
//但是坑点有：炸弹范围超过极限后固定到极限，相当于一次炸完
//wi居然可以累计，居然会爆内存，还是要小心
